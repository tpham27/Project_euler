from math import sqrt
import math
import sys
import locale
import extra_functions as extra 

alphabets = {}
list_alphabets = 'abcdefghijklmnopqrstuvwxyz'
j = 1
lettertonumber = []
for letter in list_alphabets:
	alphabets[letter] = j
	j += 1

# Problem 7
# What is the 10 001st prime number?
def problem7():
	i = 2
	prime = 3
	while i < 10001:
		no_prime = True
		while no_prime:
			prime = prime + 2
			if extra.is_prime(prime):
				no_prime = False
		i = i + 1
	return prime



# Problem 8
# Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
# Adjacent digits are in the file problem8.txt
def problem8():
	x = open('problem8.txt', r)
	len_x = len(x)
	consec_digits = 13
	max_product = 0
	for i in range(0, len_x - consec_digits):
		curr = x[i:i+consec_digits]
		if '0' not in curr and len(curr) == consec_digits:
			product = 1
			for num in curr:
				product = product * int(num)
			if product > max_product:
				max_product = product
	return max_product



# Problem 9
# There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc.
def problem9():
	a, b, c = 3, 4, 5
	test_sum = 1000
	while True:
		c = sqrt(a*a + b*b)
		total_sum = a + b + c
		if total_sum == test_sum:
			return a * b * c
		if b > 500:
			a += 1
			b = 1
		else:
			b += 1
		if a > 500:
			return "FAILURE"


# Problem 10
# Find the sum of all the primes below two million.
def problem10(): 
	bound = 2000000
	range_ints = list(range(1, bound))[::2]
	total_sum = 2
	for x in range_ints:
		if extra.is_prime(x):
			total_sum += x
	return total_sum




# Problem 11
# What is the greatest product of four adjacent numbers in the same direction 
# (up, down, left, right, or diagonally) in the 20×20 grid?
# The grid is in the file problem11.txt
def problem11():
	matrix = open('problem11.txt', 'r')
	matrix_rows = []
	for i in range(0, 20):
		real_row = []
		fake_row = matrix.readline()
		for k in range(0, 61, 3):
			entry = fake_row[k:k+2]
			if entry != '':
				entry = int(entry)
				real_row.append(entry)
		matrix_rows.append(real_row)
	# Testing row multiplications:
	max_product = 0
	for i in range(0, 20):
		curr_row = matrix_rows[i]
		for j in range(0, 17):
			curr_product = 1
			for k in range(0, 4):
				curr_product = curr_product * matrix_rows[i][j+k]
			if curr_product > max_product:
				max_product = curr_product
	#Testing column multiplications:
	for i in range(0, 20):
		for j in range(0, 17):
			curr_product = 1
			for k in range(0, 4):
				curr_product = curr_product * matrix_rows[j+k][i]
			if curr_product > max_product:
				max_product = curr_product
	#Testing right diagonal multiplications:
	for i in range(0, 17):
		for j in range(0, 17):
			curr_product = 1
			for k in range(0, 4):
				curr_product = curr_product * matrix_rows[i+k][j+k]
			if curr_product > max_product:
				max_product = curr_product
	#Testing left diagonal multiplications:
	for i in range(0, 17):
		for j in range(0, 17):
			curr_product = 1
			for k in range(1, 5):
				curr_product = curr_product * matrix_rows[i+k-1][j-k]
			if curr_product > max_product:
				max_product = curr_product
	return max_product


# Problem 12
# The sequence of triangle numbers is generated by adding the natural numbers. 
# What is the value of the first triangle number to have over five hundred divisors?
def problem12():
	bound = 500
	curr_tri_num = 1
	i = 2
	div_num = 0
	while div_num <= 500:
		#print(curr_tri_num)
		curr_tri_num += i
		i += 1
		if curr_tri_num % 2 == 1:
			div_num = 0
		elif extra.is_prime(curr_tri_num):
			div_num = 2
		else:
			div_num = extra.num_divisors(curr_tri_num)
		if div_num >= 500:
			return curr_tri_num


# Problem 13
# Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.
# The numbers are in the file problem13.txt
def problem13():
	sums = []
	sums_file = open('problem13.txt', 'r')
	for i in range(0, 100):
		if i != 99:
			curr_sum = sums_file.readline()[:-1]
			sums.append(int(curr_sum))
		else:
			curr_sum = sums_file.readline()
			sums.append(int(curr_sum))
	#print(sums)
	curr_sum = 0
	for i in range(0, 100):
		curr_entry = sums[i]
		curr_sum += curr_entry
	curr_sum = str(curr_sum)
	return curr_sum[0:10]


# Problem 14
# Longest Collatz Sequence
# Which starting number, under one million, produces the longest chain?
def problem14():
	max_chain = 0
	max_num = 0
	for i in range(500000,1000000):
		count = 0
		num = i
		while num != 1:
			if num % 2 == 0:
				num = num / 2
			else:
				num = 3 * num + 1
			count += 1
		if count > max_chain:
			max_chain = count
			max_num = i
	print("max_chain: ", max_chain, "max_num: ", max_num)


# Problem 15
# Starting in the top left corner of a 2×2 grid, and only being 
# able to move to the right and down, there are exactly 6 routes to the bottom right corner.
# How many such routes are there through a 20×20 grid?
# Combinatorics question
def problem15():
	return n_choose_k(20*2,20)


# Problem 16
# What is the sum of the digits of the number 2^(1000)?
def problem16():
	num = int(math.pow(2, 1000))
	curr_sum = 0
	while num > 0:
		digit = int(num % 10)
		print(num, digit)
		num = int(num // 10)
		curr_sum += digit
	return curr_sum



# Problem 17
# If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?
def count_letters(i):
	num_letters = {1: 3, 2: 3, 3: 5, 4: 4, 5: 4, 6: 3, 7: 5, 8: 5, 9: 4, 100: 7, 20: 6, 30: 6, 40: 5, 50: 5, 60: 5, 70: 7, 80: 6, 90: 6, 10: 3, 
		11: 6, 12: 6, 13: 8, 14: 8, 15: 7, 16: 7, 17: 9, 18: 8, 19: 8}
	if i == 1000:
		return 11
	elif i % 100 == 0:
		return num_letters[i//100] + num_letters[100]
	elif i in num_letters.keys():
		return num_letters[i]
	elif len(str(i)) == 2:
		single_digit = i % 10
		double_digit = i // 10
		double_digit = double_digit * 10
		return num_letters[single_digit] + num_letters[double_digit]
	else:
		hundreds = i // 100
		if (i % 100) in num_letters.keys():
			return num_letters[i % 100] + num_letters[hundreds] + 3 + num_letters[100]
		else:
			single_digit = i % 10
			double_digit = (i % 100) // 10
			double_digit = double_digit * 10
			return num_letters[single_digit] + num_letters[double_digit] + num_letters[hundreds] + 3 + num_letters[100]
def problem17():
	count = 0
	for i in range(1, 1001):
		count += count_letters(i)
	return count
#answer = 21124



# Problem 18
# STILL UNSOLVED! NEED TO FIND A BETTER WAY THAT ISN'T BRUTE FORCE!
# Find the maximum total from top to bottom of the triangle, in the file problem18.txt
def problem18():
	triangle_file = open('problem18.txt', 'r')
	triangle = []
	for i in range(1, 16):
		curr_line = triangle_file.readline()
		if i != 15:
			curr_line = curr_line[:-1]
		curr_line2 = []
		k = 0
		while k <= (3*i-1):
			curr_line2.append(int(curr_line[k:k+2]))
			k += 3
		triangle.append(curr_line2)
	total = triangle[0][0]
	triangle_sums = {}
	triangle_sums[0] = total
	for i in range(1, 15):
		for index in range(0, i+1):
			if index in triangle_sums.keys():
				triangle_sums[index] += max(triangle[i][index], triangle[i][index+1])
			else:
				triangle_sums[index] = triangle_sums[index-1] - triangle[i][index-1] + triangle[i][index]
	return max(triangle_sums.values())



# Problem 19
# How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?
def problem19():
	count = 0
	curr = 2
	year = 1901
	while (year <= 2000):
		if ((curr == 5) or (curr == 6)) or (curr == 0):
			#print("year: ", year, "count: ", 5, "curr: ", curr)
			count += 5
		else:
			count += 4
			#print("year: ", year, "count: ", 4, "curr: ", curr)
		if (year % 4 == 0):
			if (year % 400 == 0):
				curr += 2
				#print("LEAP YEAR")
			elif (year % 100 != 0):
				curr += 2
				#print("LEAP YEAR")
		else:
			curr += 1
		if curr % 7 == 0:
			curr = 0
		elif curr >= 7:
			curr = curr % 7
		year += 1
	return count


# Problem 19
# How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?
def problem19_2():
	count = 0
	curr = 5
	year = 1999
	thirty = [8, 3, 5, 10]
	thirtyone = [0, 2, 4, 6, 7, 9, 11]
	while (year <= 2000):
		month = 0
		while (month < 12):
			if curr == 0:
				count += 1
				#print("year: ", year, "month: ", month, "curr: ", curr)
			if month in thirty:
				curr = (curr + 30) % 7
			elif month in thirtyone:
				curr = (curr + 31) % 7
			else:
				if (year % 4) == 0:
					if ((year % 400) == 0) or ((year % 100) != 0):
						curr = (curr + 29) % 7
				else:
					curr = (curr + 28) % 7
			month += 1
		year += 1
	return count

# Problem 20
# Find the sum of the digits in the number 100!
def problem20():
	return extra.sum_digits(extra.factorial(100))


# Problem 21
# Let d(n) be defined as the sum of proper divisors of n (numbers less than n which divide evenly into n).
# If d(a) = b and d(b) = a, where a ≠ b, then a and b are an amicable pair and each of a and b are called amicable numbers.
# Evaluate the sum of all the amicable numbers under 10000.
def problem21():
	amicable = []
	in_question = {}
	for i in range(1, 10001):
		if i not in amicable:
			curr_sum = extra.sum_divisors(i)
			if curr_sum in in_question.keys():
				if in_question[curr_sum] == i:
					amicable.append(i)
					amicable.append(curr_sum)
			else:
				in_question[i] = curr_sum
	return sum(amicable)


# Problem 22
# For example, when the list is sorted into alphabetical order, COLIN, 
# which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. 
# So, COLIN would obtain a score of 938 × 53 = 49714.
# What is the total of all the name scores in the file (problem22.txt)?
def problem22():
	old_names = open('problem22.txt', 'r').read().split(",")
	names = []
	for name in old_names:
		new_name = name[1:-1]
		names.append(new_name)
	names.sort()
	total = 0
	for i in range(0, len(names)):
		curr_sum = 0
		curr_name = names[i]
		for j in range(0, len(curr_name)):
			curr_letter = curr_name[j]
			curr_sum += alphabets[curr_name[j].lower()]
		total += (i+1) * curr_sum
	return total


# Problem 23
# A number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n.
# Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.
def problem23():
	max_num = 20162
	total_sum = 0
	abundant_numbers = set()
	for i in range(1, max_num):
		if extra.sum_proper_divisors(i) > i:
			abundant_numbers.add(i)
		if not any( (i-a in abundant_numbers) for a in abundant_numbers):
			total_sum += i
	return total_sum


# Problem 24
# What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?
def problem24():
	count = 1000000
	i = 0
	digit = 9
	curr = ""
	nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
	while digit >= 0:
		curr_count = extra.factorial(digit)
		i = count // curr_count 
		temp_count = count
		count = count % curr_count
		if count == 0:
			count = temp_count
			i = count / curr_count - 1
			count = count - i
		if curr_count == 1:
			i = 1
		if i >= len(nums):
			i = i % len(nums)
		curr += str(nums[i])
		nums.remove(nums[i])
		digit = digit - 1
	return curr


# Problem 25
# What is the first term in the Fibonacci sequence to contain 1000 digits?
def problem25():
	count = 2
	digits = 1
	prev = 1
	curr = 1
	while digits < 1000:
		prev, curr = curr, prev + curr
		digits = len(str(curr))
		count += 1
	return count


# Problem 26
# Find the value of d < 1000 for which 1/d contains the longest recurring cycle in its decimal fraction part.
def problem26():
	d = 1.0
	max_digits = 1
	max_d = d
	max_list = []
	for i in range(2, 1001):
		still_recurring = True
		curr_digit = 10
		remainders = []
		curr_remainder = 0
		while still_recurring:
			curr_remainder = curr_digit % i
			curr_digit = curr_remainder * 10
			if curr_remainder in remainders:
				still_recurring = False
			else:
				remainders.append(curr_remainder)
		if len(remainders) > max_digits:
			max_d = i
			max_list = remainders
			max_digits = len(remainders)
	return max_d

# Problem 27
# Find the product of the coefficients, a and b, for the quadratic expression 
# that produces the maximum number of primes for consecutive values of n, starting with n = 0.
def problem27():
	curr_product = 0
	curr_max_primes = 0
	for a in range(-1000, 1001):
		for b in range(-1000, 1001):
			still_prime = True
			n = 0
			while still_prime:
				curr_num = abs(n * n + a * n + b)
				if extra.is_prime(curr_num):
					n += 1
				else:
					still_prime = False
			if n > curr_max_primes:
				max_A, max_B = a, b
				curr_max_primes = n
				curr_product = a * b
	return curr_product


# Problem 28
# What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?
# 1 is at the center, 2 is to the right, 3 is below, 4 is to the left (right below 1), 5 is to the left again, 6 is above 5, etc..
# REALLY FUN ONE! MOST FAVORITE SO FAR
def problem28():
	spiral_bound = 1001
	curr_sum = 1
	curr_spiral_num = 1
	for i in range(3, spiral_bound+1):
		if i % 2 == 1:
			interval = i - 1
			for j in range(1, 5):
				curr_sum += curr_spiral_num + interval
				curr_spiral_num = curr_spiral_num + interval
	return curr_sum


# Problem 29
# How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
def problem29():
	sequence = set()
	for a in range(2, 101):
		for b in range(2, 101):
			sequence.add(pow(a, b))
	return len(sequence)


# Problem 30
# Find the sum of all the numbers that can be written as the sum of fifth powers of their digits.
def problem30():
	power = 5
	correct_nums = []
	for i in range(2, 1000000):
		curr_sum = 0
		curr_num = i
		while curr_num != 0:
			curr_digit = curr_num % 10
			curr_sum += pow(curr_digit, power)
			curr_num = curr_num // 10
		if curr_sum == i:
			correct_nums.append(i)
	return sum(correct_nums)

